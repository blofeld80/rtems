// Generated by ./scripts/test.py:
//
// ./scripts/test.py -c tests/test_compat.toml -o tests/test_compat.t.a.c
//

#include "runners/test_runner.h"

#line 20 "tests/test_compat.toml"
#ifdef LFSP
#define STRINGIZE(x) STRINGIZE_(x)
#define STRINGIZE_(x) #x
#include STRINGIZE(LFSP)
#else
#define LFSP_DISK_VERSION LFS_DISK_VERSION
#define LFSP_DISK_VERSION_MAJOR LFS_DISK_VERSION_MAJOR
#define LFSP_DISK_VERSION_MINOR LFS_DISK_VERSION_MINOR
#define lfsp_t lfs_t
#define lfsp_config lfs_config
#define lfsp_format lfs_format
#define lfsp_mount lfs_mount
#define lfsp_unmount lfs_unmount
#define lfsp_fsinfo lfs_fsinfo
#define lfsp_fs_stat lfs_fs_stat
#define lfsp_dir_t lfs_dir_t
#define lfsp_info lfs_info
#define LFSP_TYPE_REG LFS_TYPE_REG
#define LFSP_TYPE_DIR LFS_TYPE_DIR
#define lfsp_mkdir lfs_mkdir
#define lfsp_dir_open lfs_dir_open
#define lfsp_dir_read lfs_dir_read
#define lfsp_dir_close lfs_dir_close
#define lfsp_file_t lfs_file_t
#define LFSP_O_RDONLY LFS_O_RDONLY
#define LFSP_O_WRONLY LFS_O_WRONLY
#define LFSP_O_CREAT LFS_O_CREAT
#define LFSP_O_EXCL LFS_O_EXCL
#define LFSP_SEEK_SET LFS_SEEK_SET
#define lfsp_file_open lfs_file_open
#define lfsp_file_write lfs_file_write
#define lfsp_file_read lfs_file_read
#define lfsp_file_seek lfs_file_seek
#define lfsp_file_close lfs_file_close
#endif
#line 45 "tests/test_compat.t.a.c"

#ifndef CHUNK
#define CHUNK_i                  TEST_IMPLICIT_DEFINE_COUNT+0
#define CHUNK                    TEST_DEFINE(CHUNK_i)
#endif
#ifndef COUNT
#define COUNT_i                  TEST_IMPLICIT_DEFINE_COUNT+1
#define COUNT                    TEST_DEFINE(COUNT_i)
#endif
#ifndef SIZE
#define SIZE_i                   TEST_IMPLICIT_DEFINE_COUNT+2
#define SIZE                     TEST_DEFINE(SIZE_i)
#endif

bool __test__test_compat_forward_mount__filter(void) {
    return (    LFS_DISK_VERSION_MAJOR == LFSP_DISK_VERSION_MAJOR
        && DISK_VERSION == 0
);
}

void __test__test_compat_forward_mount__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_forward_mount
    #line 68 "tests/test_compat.toml"
    // create the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_format(&lfsp, &cfgp) => 0;

    // confirm the previous mount works
    lfsp_mount(&lfsp, &cfgp) => 0;
    lfsp_unmount(&lfsp) => 0;


    // now test the new mount
    lfs_t lfs;
    lfs_mount(&lfs, cfg) => 0;

    // we should be able to read the version using lfs_fs_stat
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.disk_version == LFSP_DISK_VERSION);

    lfs_unmount(&lfs) => 0;
    #line 90 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_forward_read_dirs__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

const test_define_t __test__test_compat_forward_read_dirs__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [COUNT_i                 ] = {__test__test_compat_forward_read_dirs__COUNT__0, NULL},
    },
};

bool __test__test_compat_forward_read_dirs__filter(void) {
    return (    LFS_DISK_VERSION_MAJOR == LFSP_DISK_VERSION_MAJOR
        && DISK_VERSION == 0
);
}

void __test__test_compat_forward_read_dirs__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_forward_read_dirs
    #line 99 "tests/test_compat.toml"
    // create the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_format(&lfsp, &cfgp) => 0;

    // write COUNT dirs
    lfsp_mount(&lfsp, &cfgp) => 0;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfsp_mkdir(&lfsp, name) => 0;
    }
    lfsp_unmount(&lfsp) => 0;


    // mount the new version
    lfs_t lfs;
    lfs_mount(&lfs, cfg) => 0;

    // we should be able to read the version using lfs_fs_stat
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.disk_version == LFSP_DISK_VERSION);

    // can we list the directories?
    lfs_dir_t dir;
    lfs_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_DIR);
        char name[8];
        sprintf(name, "dir%03d", i);
        assert(strcmp(info.name, name) == 0);
    }

    lfs_dir_read(&lfs, &dir, &info) => 0;
    lfs_dir_close(&lfs, &dir) => 0;

    lfs_unmount(&lfs) => 0;
    #line 160 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_forward_read_files__CHUNK__0(__attribute__((unused)) void *data) {
    return 4;
}

intmax_t __test__test_compat_forward_read_files__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

intmax_t __test__test_compat_forward_read_files__SIZE__1(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_compat_forward_read_files__SIZE__2(__attribute__((unused)) void *data) {
    return 512;
}

intmax_t __test__test_compat_forward_read_files__SIZE__3(__attribute__((unused)) void *data) {
    return 8192;
}

const test_define_t __test__test_compat_forward_read_files__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_read_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_read_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_read_files__CHUNK__0, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_read_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_read_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_read_files__SIZE__1, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_read_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_read_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_read_files__SIZE__2, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_read_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_read_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_read_files__SIZE__3, NULL},
    },
};

bool __test__test_compat_forward_read_files__filter(void) {
    return (    LFS_DISK_VERSION_MAJOR == LFSP_DISK_VERSION_MAJOR
        && DISK_VERSION == 0
);
}

void __test__test_compat_forward_read_files__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_forward_read_files
    #line 159 "tests/test_compat.toml"
    // create the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_format(&lfsp, &cfgp) => 0;

    // write COUNT files
    lfsp_mount(&lfsp, &cfgp) => 0;
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfsp_file_open(&lfsp, &file, name,
                LFSP_O_WRONLY | LFSP_O_CREAT | LFSP_O_EXCL) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfsp_file_write(&lfsp, &file, chunk, CHUNK) => CHUNK;
        }
        lfsp_file_close(&lfsp, &file) => 0;
    }
    lfsp_unmount(&lfsp) => 0;


    // mount the new version
    lfs_t lfs;
    lfs_mount(&lfs, cfg) => 0;

    // we should be able to read the version using lfs_fs_stat
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.disk_version == LFSP_DISK_VERSION);

    // can we list the files?
    lfs_dir_t dir;
    lfs_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_REG);
        char name[8];
        sprintf(name, "file%03d", i);
        assert(strcmp(info.name, name) == 0);
        assert(info.size == SIZE);
    }

    lfs_dir_read(&lfs, &dir, &info) => 0;

    // now can we read the files?
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfs_file_open(&lfs, &file, name, LFS_O_RDONLY) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            lfs_file_read(&lfs, &file, chunk, CHUNK) => CHUNK;

            for (lfs_size_t k = 0; k < CHUNK; k++) {
                assert(chunk[k] == TEST_PRNG(&prng) & 0xff);
            }
        }
        lfs_file_close(&lfs, &file) => 0;
    }

    lfs_unmount(&lfs) => 0;
    #line 293 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_forward_read_files_in_dirs__CHUNK__0(__attribute__((unused)) void *data) {
    return 4;
}

intmax_t __test__test_compat_forward_read_files_in_dirs__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

intmax_t __test__test_compat_forward_read_files_in_dirs__SIZE__1(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_compat_forward_read_files_in_dirs__SIZE__2(__attribute__((unused)) void *data) {
    return 512;
}

intmax_t __test__test_compat_forward_read_files_in_dirs__SIZE__3(__attribute__((unused)) void *data) {
    return 8192;
}

const test_define_t __test__test_compat_forward_read_files_in_dirs__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_read_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_read_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_read_files_in_dirs__CHUNK__0, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_read_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_read_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_read_files_in_dirs__SIZE__1, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_read_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_read_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_read_files_in_dirs__SIZE__2, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_read_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_read_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_read_files_in_dirs__SIZE__3, NULL},
    },
};

bool __test__test_compat_forward_read_files_in_dirs__filter(void) {
    return (    LFS_DISK_VERSION_MAJOR == LFSP_DISK_VERSION_MAJOR
        && DISK_VERSION == 0
);
}

void __test__test_compat_forward_read_files_in_dirs__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_forward_read_files_in_dirs
    #line 249 "tests/test_compat.toml"
    // create the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_format(&lfsp, &cfgp) => 0;

    // write COUNT files+dirs
    lfsp_mount(&lfsp, &cfgp) => 0;
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[16];
        sprintf(name, "dir%03d", i);
        lfsp_mkdir(&lfsp, name) => 0;

        lfsp_file_t file;
        sprintf(name, "dir%03d/file%03d", i, i);
        lfsp_file_open(&lfsp, &file, name,
                LFSP_O_WRONLY | LFSP_O_CREAT | LFSP_O_EXCL) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfsp_file_write(&lfsp, &file, chunk, CHUNK) => CHUNK;
        }
        lfsp_file_close(&lfsp, &file) => 0;
    }
    lfsp_unmount(&lfsp) => 0;


    // mount the new version
    lfs_t lfs;
    lfs_mount(&lfs, cfg) => 0;

    // we should be able to read the version using lfs_fs_stat
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.disk_version == LFSP_DISK_VERSION);

    // can we list the directories?
    lfs_dir_t dir;
    lfs_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_DIR);
        char name[8];
        sprintf(name, "dir%03d", i);
        assert(strcmp(info.name, name) == 0);
    }

    lfs_dir_read(&lfs, &dir, &info) => 0;
    lfs_dir_close(&lfs, &dir) => 0;

    // can we list the files?
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfs_dir_t dir;
        lfs_dir_open(&lfs, &dir, name) => 0;
        struct lfs_info info;
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_DIR);
        assert(strcmp(info.name, ".") == 0);
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_DIR);
        assert(strcmp(info.name, "..") == 0);

        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_REG);
        sprintf(name, "file%03d", i);
        assert(strcmp(info.name, name) == 0);
        assert(info.size == SIZE);

        lfs_dir_read(&lfs, &dir, &info) => 0;
        lfs_dir_close(&lfs, &dir) => 0;
    }

    // now can we read the files?
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_file_t file;
        char name[16];
        sprintf(name, "dir%03d/file%03d", i, i);
        lfs_file_open(&lfs, &file, name, LFS_O_RDONLY) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            lfs_file_read(&lfs, &file, chunk, CHUNK) => CHUNK;

            for (lfs_size_t k = 0; k < CHUNK; k++) {
                assert(chunk[k] == TEST_PRNG(&prng) & 0xff);
            }
        }
        lfs_file_close(&lfs, &file) => 0;
    }

    lfs_unmount(&lfs) => 0;
    #line 453 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_forward_write_dirs__COUNT__0(__attribute__((unused)) void *data) {
    return 10;
}

const test_define_t __test__test_compat_forward_write_dirs__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [COUNT_i                 ] = {__test__test_compat_forward_write_dirs__COUNT__0, NULL},
    },
};

bool __test__test_compat_forward_write_dirs__filter(void) {
    return (    LFS_DISK_VERSION_MAJOR == LFSP_DISK_VERSION_MAJOR
        && DISK_VERSION == 0
);
}

void __test__test_compat_forward_write_dirs__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_forward_write_dirs
    #line 364 "tests/test_compat.toml"
    // create the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_format(&lfsp, &cfgp) => 0;

    // write COUNT/2 dirs
    lfsp_mount(&lfsp, &cfgp) => 0;
    for (lfs_size_t i = 0; i < COUNT/2; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfsp_mkdir(&lfsp, name) => 0;
    }
    lfsp_unmount(&lfsp) => 0;


    // mount the new version
    lfs_t lfs;
    lfs_mount(&lfs, cfg) => 0;

    // we should be able to read the version using lfs_fs_stat
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.disk_version == LFSP_DISK_VERSION);

    // write another COUNT/2 dirs
    for (lfs_size_t i = COUNT/2; i < COUNT; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfs_mkdir(&lfs, name) => 0;
    }

    // can we list the directories?
    lfs_dir_t dir;
    lfs_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_DIR);
        char name[8];
        sprintf(name, "dir%03d", i);
        assert(strcmp(info.name, name) == 0);
    }

    lfs_dir_read(&lfs, &dir, &info) => 0;
    lfs_dir_close(&lfs, &dir) => 0;

    lfs_unmount(&lfs) => 0;
    #line 530 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_forward_write_files__CHUNK__0(__attribute__((unused)) void *data) {
    return 2;
}

intmax_t __test__test_compat_forward_write_files__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

intmax_t __test__test_compat_forward_write_files__SIZE__0(__attribute__((unused)) void *data) {
    return 4;
}

intmax_t __test__test_compat_forward_write_files__SIZE__1(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_compat_forward_write_files__SIZE__2(__attribute__((unused)) void *data) {
    return 512;
}

intmax_t __test__test_compat_forward_write_files__SIZE__3(__attribute__((unused)) void *data) {
    return 8192;
}

const test_define_t __test__test_compat_forward_write_files__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_write_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_write_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_write_files__SIZE__0, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_write_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_write_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_write_files__SIZE__1, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_write_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_write_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_write_files__SIZE__2, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_write_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_write_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_write_files__SIZE__3, NULL},
    },
};

bool __test__test_compat_forward_write_files__filter(void) {
    return (    LFS_DISK_VERSION_MAJOR == LFSP_DISK_VERSION_MAJOR
        && DISK_VERSION == 0
);
}

void __test__test_compat_forward_write_files__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_forward_write_files
    #line 431 "tests/test_compat.toml"
    // create the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_format(&lfsp, &cfgp) => 0;

    // write half COUNT files
    lfsp_mount(&lfsp, &cfgp) => 0;
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        // write half
        lfsp_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfsp_file_open(&lfsp, &file, name,
                LFSP_O_WRONLY | LFSP_O_CREAT | LFSP_O_EXCL) => 0;
        for (lfs_size_t j = 0; j < SIZE/2; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfsp_file_write(&lfsp, &file, chunk, CHUNK) => CHUNK;
        }
        lfsp_file_close(&lfsp, &file) => 0;

        // skip the other half but keep our prng reproducible
        for (lfs_size_t j = SIZE/2; j < SIZE; j++) {
            TEST_PRNG(&prng);
        }
    }
    lfsp_unmount(&lfsp) => 0;


    // mount the new version
    lfs_t lfs;
    lfs_mount(&lfs, cfg) => 0;

    // we should be able to read the version using lfs_fs_stat
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.disk_version == LFSP_DISK_VERSION);

    // write half COUNT files
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        // skip half but keep our prng reproducible
        for (lfs_size_t j = 0; j < SIZE/2; j++) {
            TEST_PRNG(&prng);
        }

        // write the other half
        lfs_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfs_file_open(&lfs, &file, name, LFS_O_WRONLY) => 0;
        lfs_file_seek(&lfs, &file, SIZE/2, LFS_SEEK_SET) => SIZE/2;

        for (lfs_size_t j = SIZE/2; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfs_file_write(&lfs, &file, chunk, CHUNK) => CHUNK;
        }
        lfs_file_close(&lfs, &file) => 0;
    }

    // can we list the files?
    lfs_dir_t dir;
    lfs_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_REG);
        char name[8];
        sprintf(name, "file%03d", i);
        assert(strcmp(info.name, name) == 0);
        assert(info.size == SIZE);
    }

    lfs_dir_read(&lfs, &dir, &info) => 0;

    // now can we read the files?
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfs_file_open(&lfs, &file, name, LFS_O_RDONLY) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            lfs_file_read(&lfs, &file, chunk, CHUNK) => CHUNK;

            for (lfs_size_t k = 0; k < CHUNK; k++) {
                assert(chunk[k] == TEST_PRNG(&prng) & 0xff);
            }
        }
        lfs_file_close(&lfs, &file) => 0;
    }

    lfs_unmount(&lfs) => 0;
    #line 699 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_forward_write_files_in_dirs__CHUNK__0(__attribute__((unused)) void *data) {
    return 2;
}

intmax_t __test__test_compat_forward_write_files_in_dirs__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

intmax_t __test__test_compat_forward_write_files_in_dirs__SIZE__0(__attribute__((unused)) void *data) {
    return 4;
}

intmax_t __test__test_compat_forward_write_files_in_dirs__SIZE__1(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_compat_forward_write_files_in_dirs__SIZE__2(__attribute__((unused)) void *data) {
    return 512;
}

intmax_t __test__test_compat_forward_write_files_in_dirs__SIZE__3(__attribute__((unused)) void *data) {
    return 8192;
}

const test_define_t __test__test_compat_forward_write_files_in_dirs__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_write_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_write_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_write_files_in_dirs__SIZE__0, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_write_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_write_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_write_files_in_dirs__SIZE__1, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_write_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_write_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_write_files_in_dirs__SIZE__2, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_forward_write_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_forward_write_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_forward_write_files_in_dirs__SIZE__3, NULL},
    },
};

bool __test__test_compat_forward_write_files_in_dirs__filter(void) {
    return (    LFS_DISK_VERSION_MAJOR == LFSP_DISK_VERSION_MAJOR
        && DISK_VERSION == 0
);
}

void __test__test_compat_forward_write_files_in_dirs__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_forward_write_files_in_dirs
    #line 553 "tests/test_compat.toml"
    // create the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_format(&lfsp, &cfgp) => 0;

    // write half COUNT files
    lfsp_mount(&lfsp, &cfgp) => 0;
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[16];
        sprintf(name, "dir%03d", i);
        lfsp_mkdir(&lfsp, name) => 0;

        // write half
        lfsp_file_t file;
        sprintf(name, "dir%03d/file%03d", i, i);
        lfsp_file_open(&lfsp, &file, name,
                LFSP_O_WRONLY | LFSP_O_CREAT | LFSP_O_EXCL) => 0;
        for (lfs_size_t j = 0; j < SIZE/2; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfsp_file_write(&lfsp, &file, chunk, CHUNK) => CHUNK;
        }
        lfsp_file_close(&lfsp, &file) => 0;

        // skip the other half but keep our prng reproducible
        for (lfs_size_t j = SIZE/2; j < SIZE; j++) {
            TEST_PRNG(&prng);
        }
    }
    lfsp_unmount(&lfsp) => 0;


    // mount the new version
    lfs_t lfs;
    lfs_mount(&lfs, cfg) => 0;

    // we should be able to read the version using lfs_fs_stat
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.disk_version == LFSP_DISK_VERSION);

    // write half COUNT files
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        // skip half but keep our prng reproducible
        for (lfs_size_t j = 0; j < SIZE/2; j++) {
            TEST_PRNG(&prng);
        }

        // write the other half
        lfs_file_t file;
        char name[16];
        sprintf(name, "dir%03d/file%03d", i, i);
        lfs_file_open(&lfs, &file, name, LFS_O_WRONLY) => 0;
        lfs_file_seek(&lfs, &file, SIZE/2, LFS_SEEK_SET) => SIZE/2;

        for (lfs_size_t j = SIZE/2; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfs_file_write(&lfs, &file, chunk, CHUNK) => CHUNK;
        }
        lfs_file_close(&lfs, &file) => 0;
    }

    // can we list the directories?
    lfs_dir_t dir;
    lfs_dir_open(&lfs, &dir, "/") => 0;
    struct lfs_info info;
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfs_dir_read(&lfs, &dir, &info) => 1;
    assert(info.type == LFS_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_DIR);
        char name[8];
        sprintf(name, "dir%03d", i);
        assert(strcmp(info.name, name) == 0);
    }

    lfs_dir_read(&lfs, &dir, &info) => 0;
    lfs_dir_close(&lfs, &dir) => 0;

    // can we list the files?
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfs_dir_t dir;
        lfs_dir_open(&lfs, &dir, name) => 0;
        struct lfs_info info;
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_DIR);
        assert(strcmp(info.name, ".") == 0);
        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_DIR);
        assert(strcmp(info.name, "..") == 0);

        lfs_dir_read(&lfs, &dir, &info) => 1;
        assert(info.type == LFS_TYPE_REG);
        sprintf(name, "file%03d", i);
        assert(strcmp(info.name, name) == 0);
        assert(info.size == SIZE);

        lfs_dir_read(&lfs, &dir, &info) => 0;
        lfs_dir_close(&lfs, &dir) => 0;
    }

    // now can we read the files?
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_file_t file;
        char name[16];
        sprintf(name, "dir%03d/file%03d", i, i);
        lfs_file_open(&lfs, &file, name, LFS_O_RDONLY) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            lfs_file_read(&lfs, &file, chunk, CHUNK) => CHUNK;

            for (lfs_size_t k = 0; k < CHUNK; k++) {
                assert(chunk[k] == TEST_PRNG(&prng) & 0xff);
            }
        }
        lfs_file_close(&lfs, &file) => 0;
    }

    lfs_unmount(&lfs) => 0;
    #line 895 "tests/test_compat.t.a.c"
}

bool __test__test_compat_backward_mount__filter(void) {
    return (    LFS_DISK_VERSION == LFSP_DISK_VERSION
        && DISK_VERSION == 0
);
}

void __test__test_compat_backward_mount__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_backward_mount
    #line 703 "tests/test_compat.toml"
    // create the new version
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // confirm the new mount works
    lfs_mount(&lfs, cfg) => 0;
    lfs_unmount(&lfs) => 0;

    // now test the previous mount
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_mount(&lfsp, &cfgp) => 0;

    lfsp_unmount(&lfsp) => 0;
    #line 922 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_backward_read_dirs__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

const test_define_t __test__test_compat_backward_read_dirs__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [COUNT_i                 ] = {__test__test_compat_backward_read_dirs__COUNT__0, NULL},
    },
};

bool __test__test_compat_backward_read_dirs__filter(void) {
    return (    LFS_DISK_VERSION == LFSP_DISK_VERSION
        && DISK_VERSION == 0
);
}

void __test__test_compat_backward_read_dirs__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_backward_read_dirs
    #line 728 "tests/test_compat.toml"
    // create the new version
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // write COUNT dirs
    lfs_mount(&lfs, cfg) => 0;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfs_mkdir(&lfs, name) => 0;
    }
    lfs_unmount(&lfs) => 0;


    // mount the new version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_mount(&lfsp, &cfgp) => 0;

    // can we list the directories?
    lfsp_dir_t dir;
    lfsp_dir_open(&lfsp, &dir, "/") => 0;
    struct lfsp_info info;
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_DIR);
        char name[8];
        sprintf(name, "dir%03d", i);
        assert(strcmp(info.name, name) == 0);
    }

    lfsp_dir_read(&lfsp, &dir, &info) => 0;
    lfsp_dir_close(&lfsp, &dir) => 0;

    lfsp_unmount(&lfsp) => 0;
    #line 987 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_backward_read_files__CHUNK__0(__attribute__((unused)) void *data) {
    return 4;
}

intmax_t __test__test_compat_backward_read_files__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

intmax_t __test__test_compat_backward_read_files__SIZE__1(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_compat_backward_read_files__SIZE__2(__attribute__((unused)) void *data) {
    return 512;
}

intmax_t __test__test_compat_backward_read_files__SIZE__3(__attribute__((unused)) void *data) {
    return 8192;
}

const test_define_t __test__test_compat_backward_read_files__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_read_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_read_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_read_files__CHUNK__0, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_read_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_read_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_read_files__SIZE__1, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_read_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_read_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_read_files__SIZE__2, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_read_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_read_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_read_files__SIZE__3, NULL},
    },
};

bool __test__test_compat_backward_read_files__filter(void) {
    return (    LFS_DISK_VERSION == LFSP_DISK_VERSION
        && DISK_VERSION == 0
);
}

void __test__test_compat_backward_read_files__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_backward_read_files
    #line 783 "tests/test_compat.toml"
    // create the new version
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // write COUNT files
    lfs_mount(&lfs, cfg) => 0;
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfs_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfs_file_open(&lfs, &file, name,
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfs_file_write(&lfs, &file, chunk, CHUNK) => CHUNK;
        }
        lfs_file_close(&lfs, &file) => 0;
    }
    lfs_unmount(&lfs) => 0;


    // mount the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_mount(&lfsp, &cfgp) => 0;

    // can we list the files?
    lfsp_dir_t dir;
    lfsp_dir_open(&lfsp, &dir, "/") => 0;
    struct lfsp_info info;
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_REG);
        char name[8];
        sprintf(name, "file%03d", i);
        assert(strcmp(info.name, name) == 0);
        assert(info.size == SIZE);
    }

    lfsp_dir_read(&lfsp, &dir, &info) => 0;

    // now can we read the files?
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfsp_file_open(&lfsp, &file, name, LFSP_O_RDONLY) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            lfsp_file_read(&lfsp, &file, chunk, CHUNK) => CHUNK;

            for (lfs_size_t k = 0; k < CHUNK; k++) {
                assert(chunk[k] == TEST_PRNG(&prng) & 0xff);
            }
        }
        lfsp_file_close(&lfsp, &file) => 0;
    }

    lfsp_unmount(&lfsp) => 0;
    #line 1115 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_backward_read_files_in_dirs__CHUNK__0(__attribute__((unused)) void *data) {
    return 4;
}

intmax_t __test__test_compat_backward_read_files_in_dirs__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

intmax_t __test__test_compat_backward_read_files_in_dirs__SIZE__1(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_compat_backward_read_files_in_dirs__SIZE__2(__attribute__((unused)) void *data) {
    return 512;
}

intmax_t __test__test_compat_backward_read_files_in_dirs__SIZE__3(__attribute__((unused)) void *data) {
    return 8192;
}

const test_define_t __test__test_compat_backward_read_files_in_dirs__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_read_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_read_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_read_files_in_dirs__CHUNK__0, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_read_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_read_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_read_files_in_dirs__SIZE__1, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_read_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_read_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_read_files_in_dirs__SIZE__2, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_read_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_read_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_read_files_in_dirs__SIZE__3, NULL},
    },
};

bool __test__test_compat_backward_read_files_in_dirs__filter(void) {
    return (    LFS_DISK_VERSION == LFSP_DISK_VERSION
        && DISK_VERSION == 0
);
}

void __test__test_compat_backward_read_files_in_dirs__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_backward_read_files_in_dirs
    #line 868 "tests/test_compat.toml"
    // create the new version
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // write COUNT files+dirs
    lfs_mount(&lfs, cfg) => 0;
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[16];
        sprintf(name, "dir%03d", i);
        lfs_mkdir(&lfs, name) => 0;

        lfs_file_t file;
        sprintf(name, "dir%03d/file%03d", i, i);
        lfs_file_open(&lfs, &file, name,
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfs_file_write(&lfs, &file, chunk, CHUNK) => CHUNK;
        }
        lfs_file_close(&lfs, &file) => 0;
    }
    lfs_unmount(&lfs) => 0;


    // mount the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_mount(&lfsp, &cfgp) => 0;

    // can we list the directories?
    lfsp_dir_t dir;
    lfsp_dir_open(&lfsp, &dir, "/") => 0;
    struct lfsp_info info;
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_DIR);
        char name[8];
        sprintf(name, "dir%03d", i);
        assert(strcmp(info.name, name) == 0);
    }

    lfsp_dir_read(&lfsp, &dir, &info) => 0;
    lfsp_dir_close(&lfsp, &dir) => 0;

    // can we list the files?
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfsp_dir_t dir;
        lfsp_dir_open(&lfsp, &dir, name) => 0;
        struct lfsp_info info;
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_DIR);
        assert(strcmp(info.name, ".") == 0);
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_DIR);
        assert(strcmp(info.name, "..") == 0);

        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_REG);
        sprintf(name, "file%03d", i);
        assert(strcmp(info.name, name) == 0);
        assert(info.size == SIZE);

        lfsp_dir_read(&lfsp, &dir, &info) => 0;
        lfsp_dir_close(&lfsp, &dir) => 0;
    }

    // now can we read the files?
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_file_t file;
        char name[16];
        sprintf(name, "dir%03d/file%03d", i, i);
        lfsp_file_open(&lfsp, &file, name, LFSP_O_RDONLY) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            lfsp_file_read(&lfsp, &file, chunk, CHUNK) => CHUNK;

            for (lfs_size_t k = 0; k < CHUNK; k++) {
                assert(chunk[k] == TEST_PRNG(&prng) & 0xff);
            }
        }
        lfsp_file_close(&lfsp, &file) => 0;
    }

    lfsp_unmount(&lfsp) => 0;
    #line 1270 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_backward_write_dirs__COUNT__0(__attribute__((unused)) void *data) {
    return 10;
}

const test_define_t __test__test_compat_backward_write_dirs__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [COUNT_i                 ] = {__test__test_compat_backward_write_dirs__COUNT__0, NULL},
    },
};

bool __test__test_compat_backward_write_dirs__filter(void) {
    return (    LFS_DISK_VERSION == LFSP_DISK_VERSION
        && DISK_VERSION == 0
);
}

void __test__test_compat_backward_write_dirs__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_backward_write_dirs
    #line 978 "tests/test_compat.toml"
    // create the new version
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // write COUNT/2 dirs
    lfs_mount(&lfs, cfg) => 0;
    for (lfs_size_t i = 0; i < COUNT/2; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfs_mkdir(&lfs, name) => 0;
    }
    lfs_unmount(&lfs) => 0;


    // mount the previous version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_mount(&lfsp, &cfgp) => 0;

    // write another COUNT/2 dirs
    for (lfs_size_t i = COUNT/2; i < COUNT; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfsp_mkdir(&lfsp, name) => 0;
    }

    // can we list the directories?
    lfsp_dir_t dir;
    lfsp_dir_open(&lfsp, &dir, "/") => 0;
    struct lfsp_info info;
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_DIR);
        char name[8];
        sprintf(name, "dir%03d", i);
        assert(strcmp(info.name, name) == 0);
    }

    lfsp_dir_read(&lfsp, &dir, &info) => 0;
    lfsp_dir_close(&lfsp, &dir) => 0;

    lfsp_unmount(&lfsp) => 0;
    #line 1342 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_backward_write_files__CHUNK__0(__attribute__((unused)) void *data) {
    return 2;
}

intmax_t __test__test_compat_backward_write_files__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

intmax_t __test__test_compat_backward_write_files__SIZE__0(__attribute__((unused)) void *data) {
    return 4;
}

intmax_t __test__test_compat_backward_write_files__SIZE__1(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_compat_backward_write_files__SIZE__2(__attribute__((unused)) void *data) {
    return 512;
}

intmax_t __test__test_compat_backward_write_files__SIZE__3(__attribute__((unused)) void *data) {
    return 8192;
}

const test_define_t __test__test_compat_backward_write_files__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_write_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_write_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_write_files__SIZE__0, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_write_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_write_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_write_files__SIZE__1, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_write_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_write_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_write_files__SIZE__2, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_write_files__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_write_files__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_write_files__SIZE__3, NULL},
    },
};

bool __test__test_compat_backward_write_files__filter(void) {
    return (    LFS_DISK_VERSION == LFSP_DISK_VERSION
        && DISK_VERSION == 0
);
}

void __test__test_compat_backward_write_files__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_backward_write_files
    #line 1040 "tests/test_compat.toml"
    // create the previous version
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // write half COUNT files
    lfs_mount(&lfs, cfg) => 0;
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        // write half
        lfs_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfs_file_open(&lfs, &file, name,
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        for (lfs_size_t j = 0; j < SIZE/2; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfs_file_write(&lfs, &file, chunk, CHUNK) => CHUNK;
        }
        lfs_file_close(&lfs, &file) => 0;

        // skip the other half but keep our prng reproducible
        for (lfs_size_t j = SIZE/2; j < SIZE; j++) {
            TEST_PRNG(&prng);
        }
    }
    lfs_unmount(&lfs) => 0;


    // mount the new version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_mount(&lfsp, &cfgp) => 0;

    // write half COUNT files
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        // skip half but keep our prng reproducible
        for (lfs_size_t j = 0; j < SIZE/2; j++) {
            TEST_PRNG(&prng);
        }

        // write the other half
        lfsp_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfsp_file_open(&lfsp, &file, name, LFSP_O_WRONLY) => 0;
        lfsp_file_seek(&lfsp, &file, SIZE/2, LFSP_SEEK_SET) => SIZE/2;

        for (lfs_size_t j = SIZE/2; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfsp_file_write(&lfsp, &file, chunk, CHUNK) => CHUNK;
        }
        lfsp_file_close(&lfsp, &file) => 0;
    }

    // can we list the files?
    lfsp_dir_t dir;
    lfsp_dir_open(&lfsp, &dir, "/") => 0;
    struct lfsp_info info;
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_REG);
        char name[8];
        sprintf(name, "file%03d", i);
        assert(strcmp(info.name, name) == 0);
        assert(info.size == SIZE);
    }

    lfsp_dir_read(&lfsp, &dir, &info) => 0;

    // now can we read the files?
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_file_t file;
        char name[8];
        sprintf(name, "file%03d", i);
        lfsp_file_open(&lfsp, &file, name, LFSP_O_RDONLY) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            lfsp_file_read(&lfsp, &file, chunk, CHUNK) => CHUNK;

            for (lfs_size_t k = 0; k < CHUNK; k++) {
                assert(chunk[k] == TEST_PRNG(&prng) & 0xff);
            }
        }
        lfsp_file_close(&lfsp, &file) => 0;
    }

    lfsp_unmount(&lfsp) => 0;
    #line 1506 "tests/test_compat.t.a.c"
}

intmax_t __test__test_compat_backward_write_files_in_dirs__CHUNK__0(__attribute__((unused)) void *data) {
    return 2;
}

intmax_t __test__test_compat_backward_write_files_in_dirs__COUNT__0(__attribute__((unused)) void *data) {
    return 5;
}

intmax_t __test__test_compat_backward_write_files_in_dirs__SIZE__0(__attribute__((unused)) void *data) {
    return 4;
}

intmax_t __test__test_compat_backward_write_files_in_dirs__SIZE__1(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_compat_backward_write_files_in_dirs__SIZE__2(__attribute__((unused)) void *data) {
    return 512;
}

intmax_t __test__test_compat_backward_write_files_in_dirs__SIZE__3(__attribute__((unused)) void *data) {
    return 8192;
}

const test_define_t __test__test_compat_backward_write_files_in_dirs__defines[][TEST_IMPLICIT_DEFINE_COUNT+3] = {
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_write_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_write_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_write_files_in_dirs__SIZE__0, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_write_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_write_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_write_files_in_dirs__SIZE__1, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_write_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_write_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_write_files_in_dirs__SIZE__2, NULL},
    },
    {
        [CHUNK_i                 ] = {__test__test_compat_backward_write_files_in_dirs__CHUNK__0, NULL},
        [COUNT_i                 ] = {__test__test_compat_backward_write_files_in_dirs__COUNT__0, NULL},
        [SIZE_i                  ] = {__test__test_compat_backward_write_files_in_dirs__SIZE__3, NULL},
    },
};

bool __test__test_compat_backward_write_files_in_dirs__filter(void) {
    return (    LFS_DISK_VERSION == LFSP_DISK_VERSION
        && DISK_VERSION == 0
);
}

void __test__test_compat_backward_write_files_in_dirs__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_compat_backward_write_files_in_dirs
    #line 1157 "tests/test_compat.toml"
    // create the previous version
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // write half COUNT files
    lfs_mount(&lfs, cfg) => 0;
    uint32_t prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[16];
        sprintf(name, "dir%03d", i);
        lfs_mkdir(&lfs, name) => 0;

        // write half
        lfs_file_t file;
        sprintf(name, "dir%03d/file%03d", i, i);
        lfs_file_open(&lfs, &file, name,
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        for (lfs_size_t j = 0; j < SIZE/2; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfs_file_write(&lfs, &file, chunk, CHUNK) => CHUNK;
        }
        lfs_file_close(&lfs, &file) => 0;

        // skip the other half but keep our prng reproducible
        for (lfs_size_t j = SIZE/2; j < SIZE; j++) {
            TEST_PRNG(&prng);
        }
    }
    lfs_unmount(&lfs) => 0;


    // mount the new version
    struct lfsp_config cfgp;
    memcpy(&cfgp, cfg, sizeof(cfgp));
    lfsp_t lfsp;
    lfsp_mount(&lfsp, &cfgp) => 0;

    // write half COUNT files
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        // skip half but keep our prng reproducible
        for (lfs_size_t j = 0; j < SIZE/2; j++) {
            TEST_PRNG(&prng);
        }

        // write the other half
        lfsp_file_t file;
        char name[16];
        sprintf(name, "dir%03d/file%03d", i, i);
        lfsp_file_open(&lfsp, &file, name, LFSP_O_WRONLY) => 0;
        lfsp_file_seek(&lfsp, &file, SIZE/2, LFSP_SEEK_SET) => SIZE/2;

        for (lfs_size_t j = SIZE/2; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            for (lfs_size_t k = 0; k < CHUNK; k++) {
                chunk[k] = TEST_PRNG(&prng) & 0xff;
            }

            lfsp_file_write(&lfsp, &file, chunk, CHUNK) => CHUNK;
        }
        lfsp_file_close(&lfsp, &file) => 0;
    }

    // can we list the directories?
    lfsp_dir_t dir;
    lfsp_dir_open(&lfsp, &dir, "/") => 0;
    struct lfsp_info info;
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, ".") == 0);
    lfsp_dir_read(&lfsp, &dir, &info) => 1;
    assert(info.type == LFSP_TYPE_DIR);
    assert(strcmp(info.name, "..") == 0);

    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_DIR);
        char name[8];
        sprintf(name, "dir%03d", i);
        assert(strcmp(info.name, name) == 0);
    }

    lfsp_dir_read(&lfsp, &dir, &info) => 0;
    lfsp_dir_close(&lfsp, &dir) => 0;

    // can we list the files?
    for (lfs_size_t i = 0; i < COUNT; i++) {
        char name[8];
        sprintf(name, "dir%03d", i);
        lfsp_dir_t dir;
        lfsp_dir_open(&lfsp, &dir, name) => 0;
        struct lfsp_info info;
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_DIR);
        assert(strcmp(info.name, ".") == 0);
        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_DIR);
        assert(strcmp(info.name, "..") == 0);

        lfsp_dir_read(&lfsp, &dir, &info) => 1;
        assert(info.type == LFSP_TYPE_REG);
        sprintf(name, "file%03d", i);
        assert(strcmp(info.name, name) == 0);
        assert(info.size == SIZE);

        lfsp_dir_read(&lfsp, &dir, &info) => 0;
        lfsp_dir_close(&lfsp, &dir) => 0;
    }

    // now can we read the files?
    prng = 42;
    for (lfs_size_t i = 0; i < COUNT; i++) {
        lfsp_file_t file;
        char name[16];
        sprintf(name, "dir%03d/file%03d", i, i);
        lfsp_file_open(&lfsp, &file, name, LFSP_O_RDONLY) => 0;
        for (lfs_size_t j = 0; j < SIZE; j += CHUNK) {
            uint8_t chunk[CHUNK];
            lfsp_file_read(&lfsp, &file, chunk, CHUNK) => CHUNK;

            for (lfs_size_t k = 0; k < CHUNK; k++) {
                assert(chunk[k] == TEST_PRNG(&prng) & 0xff);
            }
        }
        lfsp_file_close(&lfsp, &file) => 0;
    }

    lfsp_unmount(&lfsp) => 0;
    #line 1697 "tests/test_compat.t.a.c"
}

extern void __test__test_compat_major_incompat__run(struct lfs_config *cfg);

extern void __test__test_compat_minor_incompat__run(struct lfs_config *cfg);

extern bool __test__test_compat_minor_bump__filter(void);
extern void __test__test_compat_minor_bump__run(struct lfs_config *cfg);

__attribute__((section("_test_suites"), aligned(1)))
const struct test_suite __test__test_compat__suite = {
    .name = "test_compat",
    .path = "tests/test_compat.toml",
    .flags = 0,
    .define_names = (const char *const[TEST_IMPLICIT_DEFINE_COUNT+3]){
        [CHUNK_i                 ] = "CHUNK",
        [COUNT_i                 ] = "COUNT",
        [SIZE_i                  ] = "SIZE",
    },
    .define_count = TEST_IMPLICIT_DEFINE_COUNT+3,
    .cases = (const struct test_case[]){
        {
            .name = "test_compat_forward_mount",
            .path = "tests/test_compat.toml:62",
            .flags = 0,
            .permutations = 1,
            .filter = __test__test_compat_forward_mount__filter,
            .run = __test__test_compat_forward_mount__run,
        },
        {
            .name = "test_compat_forward_read_dirs",
            .path = "tests/test_compat.toml:92",
            .flags = 0,
            .permutations = 1,
            .defines = (const test_define_t*)__test__test_compat_forward_read_dirs__defines,
            .filter = __test__test_compat_forward_read_dirs__filter,
            .run = __test__test_compat_forward_read_dirs__run,
        },
        {
            .name = "test_compat_forward_read_files",
            .path = "tests/test_compat.toml:150",
            .flags = 0,
            .permutations = 4,
            .defines = (const test_define_t*)__test__test_compat_forward_read_files__defines,
            .filter = __test__test_compat_forward_read_files__filter,
            .run = __test__test_compat_forward_read_files__run,
        },
        {
            .name = "test_compat_forward_read_files_in_dirs",
            .path = "tests/test_compat.toml:240",
            .flags = 0,
            .permutations = 4,
            .defines = (const test_define_t*)__test__test_compat_forward_read_files_in_dirs__defines,
            .filter = __test__test_compat_forward_read_files_in_dirs__filter,
            .run = __test__test_compat_forward_read_files_in_dirs__run,
        },
        {
            .name = "test_compat_forward_write_dirs",
            .path = "tests/test_compat.toml:357",
            .flags = 0,
            .permutations = 1,
            .defines = (const test_define_t*)__test__test_compat_forward_write_dirs__defines,
            .filter = __test__test_compat_forward_write_dirs__filter,
            .run = __test__test_compat_forward_write_dirs__run,
        },
        {
            .name = "test_compat_forward_write_files",
            .path = "tests/test_compat.toml:422",
            .flags = 0,
            .permutations = 4,
            .defines = (const test_define_t*)__test__test_compat_forward_write_files__defines,
            .filter = __test__test_compat_forward_write_files__filter,
            .run = __test__test_compat_forward_write_files__run,
        },
        {
            .name = "test_compat_forward_write_files_in_dirs",
            .path = "tests/test_compat.toml:544",
            .flags = 0,
            .permutations = 4,
            .defines = (const test_define_t*)__test__test_compat_forward_write_files_in_dirs__defines,
            .filter = __test__test_compat_forward_write_files_in_dirs__filter,
            .run = __test__test_compat_forward_write_files_in_dirs__run,
        },
        {
            .name = "test_compat_backward_mount",
            .path = "tests/test_compat.toml:697",
            .flags = 0,
            .permutations = 1,
            .filter = __test__test_compat_backward_mount__filter,
            .run = __test__test_compat_backward_mount__run,
        },
        {
            .name = "test_compat_backward_read_dirs",
            .path = "tests/test_compat.toml:721",
            .flags = 0,
            .permutations = 1,
            .defines = (const test_define_t*)__test__test_compat_backward_read_dirs__defines,
            .filter = __test__test_compat_backward_read_dirs__filter,
            .run = __test__test_compat_backward_read_dirs__run,
        },
        {
            .name = "test_compat_backward_read_files",
            .path = "tests/test_compat.toml:774",
            .flags = 0,
            .permutations = 4,
            .defines = (const test_define_t*)__test__test_compat_backward_read_files__defines,
            .filter = __test__test_compat_backward_read_files__filter,
            .run = __test__test_compat_backward_read_files__run,
        },
        {
            .name = "test_compat_backward_read_files_in_dirs",
            .path = "tests/test_compat.toml:859",
            .flags = 0,
            .permutations = 4,
            .defines = (const test_define_t*)__test__test_compat_backward_read_files_in_dirs__defines,
            .filter = __test__test_compat_backward_read_files_in_dirs__filter,
            .run = __test__test_compat_backward_read_files_in_dirs__run,
        },
        {
            .name = "test_compat_backward_write_dirs",
            .path = "tests/test_compat.toml:971",
            .flags = 0,
            .permutations = 1,
            .defines = (const test_define_t*)__test__test_compat_backward_write_dirs__defines,
            .filter = __test__test_compat_backward_write_dirs__filter,
            .run = __test__test_compat_backward_write_dirs__run,
        },
        {
            .name = "test_compat_backward_write_files",
            .path = "tests/test_compat.toml:1031",
            .flags = 0,
            .permutations = 4,
            .defines = (const test_define_t*)__test__test_compat_backward_write_files__defines,
            .filter = __test__test_compat_backward_write_files__filter,
            .run = __test__test_compat_backward_write_files__run,
        },
        {
            .name = "test_compat_backward_write_files_in_dirs",
            .path = "tests/test_compat.toml:1148",
            .flags = 0,
            .permutations = 4,
            .defines = (const test_define_t*)__test__test_compat_backward_write_files_in_dirs__defines,
            .filter = __test__test_compat_backward_write_files_in_dirs__filter,
            .run = __test__test_compat_backward_write_files_in_dirs__run,
        },
        {
            .name = "test_compat_major_incompat",
            .path = "tests/test_compat.toml:1296",
            .flags = 0,
            .permutations = 1,
            .run = __test__test_compat_major_incompat__run,
        },
        {
            .name = "test_compat_minor_incompat",
            .path = "tests/test_compat.toml:1329",
            .flags = 0,
            .permutations = 1,
            .run = __test__test_compat_minor_incompat__run,
        },
        {
            .name = "test_compat_minor_bump",
            .path = "tests/test_compat.toml:1362",
            .flags = 0,
            .permutations = 1,
            .filter = __test__test_compat_minor_bump__filter,
            .run = __test__test_compat_minor_bump__run,
        },
    },
    .case_count = 17,
};

