// Generated by ./scripts/test.py:
//
// ./scripts/test.py -c tests/test_superblocks.toml -o tests/test_superblocks.t.a.c
//

#include "runners/test_runner.h"

#ifndef BLOCK_COUNT
#define BLOCK_COUNT_i            TEST_IMPLICIT_DEFINE_COUNT+0
#define BLOCK_COUNT              TEST_DEFINE(BLOCK_COUNT_i)
#endif
#ifndef BLOCK_COUNT_2
#define BLOCK_COUNT_2_i          TEST_IMPLICIT_DEFINE_COUNT+1
#define BLOCK_COUNT_2            TEST_DEFINE(BLOCK_COUNT_2_i)
#endif
#ifndef BLOCK_CYCLES
#define BLOCK_CYCLES_i           TEST_IMPLICIT_DEFINE_COUNT+2
#define BLOCK_CYCLES             TEST_DEFINE(BLOCK_CYCLES_i)
#endif
#ifndef FORMAT_BLOCK_COUNT
#define FORMAT_BLOCK_COUNT_i     TEST_IMPLICIT_DEFINE_COUNT+3
#define FORMAT_BLOCK_COUNT       TEST_DEFINE(FORMAT_BLOCK_COUNT_i)
#endif
#ifndef KNOWN_BLOCK_COUNT
#define KNOWN_BLOCK_COUNT_i      TEST_IMPLICIT_DEFINE_COUNT+4
#define KNOWN_BLOCK_COUNT        TEST_DEFINE(KNOWN_BLOCK_COUNT_i)
#endif
#ifndef N
#define N_i                      TEST_IMPLICIT_DEFINE_COUNT+5
#define N                        TEST_DEFINE(N_i)
#endif
#ifndef TWEAKED_ATTR_MAX
#define TWEAKED_ATTR_MAX_i       TEST_IMPLICIT_DEFINE_COUNT+6
#define TWEAKED_ATTR_MAX         TEST_DEFINE(TWEAKED_ATTR_MAX_i)
#endif
#ifndef TWEAKED_FILE_MAX
#define TWEAKED_FILE_MAX_i       TEST_IMPLICIT_DEFINE_COUNT+7
#define TWEAKED_FILE_MAX         TEST_DEFINE(TWEAKED_FILE_MAX_i)
#endif
#ifndef TWEAKED_NAME_MAX
#define TWEAKED_NAME_MAX_i       TEST_IMPLICIT_DEFINE_COUNT+8
#define TWEAKED_NAME_MAX         TEST_DEFINE(TWEAKED_NAME_MAX_i)
#endif

void __test__test_superblocks_format__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_format
    #line 4 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;
    #line 51 "tests/test_superblocks.t.a.c"
}

void __test__test_superblocks_mount__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_mount
    #line 11 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;
    lfs_mount(&lfs, cfg) => 0;
    lfs_unmount(&lfs) => 0;
    #line 61 "tests/test_superblocks.t.a.c"
}

void __test__test_superblocks_mount_unknown_block_count__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_mount_unknown_block_count
    #line 20 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    memset(&lfs, 0, sizeof(lfs));
    struct lfs_config tweaked_cfg = *cfg;
    tweaked_cfg.block_count = 0;
    lfs_mount(&lfs, &tweaked_cfg) => 0;
    assert(lfs.block_count == cfg->block_count);
    lfs_unmount(&lfs) => 0;
    #line 76 "tests/test_superblocks.t.a.c"
}

void __test__test_superblocks_reentrant_format__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_reentrant_format
    #line 36 "tests/test_superblocks.toml"
    lfs_t lfs;
    int err = lfs_mount(&lfs, cfg);
    if (err) {
        lfs_format(&lfs, cfg) => 0;
        lfs_mount(&lfs, cfg) => 0;
    }
    lfs_unmount(&lfs) => 0;
    #line 89 "tests/test_superblocks.t.a.c"
}

void __test__test_superblocks_invalid_mount__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_invalid_mount
    #line 48 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_mount(&lfs, cfg) => LFS_ERR_CORRUPT;
    #line 97 "tests/test_superblocks.t.a.c"
}

bool __test__test_superblocks_stat__filter(void) {
    return (DISK_VERSION == 0);
}

void __test__test_superblocks_stat__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_stat
    #line 56 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // test we can mount and read fsinfo
    lfs_mount(&lfs, cfg) => 0;

    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.disk_version == LFS_DISK_VERSION);
    assert(fsinfo.name_max == LFS_NAME_MAX);
    assert(fsinfo.file_max == LFS_FILE_MAX);
    assert(fsinfo.attr_max == LFS_ATTR_MAX);

    lfs_unmount(&lfs) => 0;
    #line 121 "tests/test_superblocks.t.a.c"
}

intmax_t __test__test_superblocks_stat_tweaked__TWEAKED_ATTR_MAX__0(__attribute__((unused)) void *data) {
    return 512;
}

intmax_t __test__test_superblocks_stat_tweaked__TWEAKED_FILE_MAX__0(__attribute__((unused)) void *data) {
    return (1 << 16)-1;
}

intmax_t __test__test_superblocks_stat_tweaked__TWEAKED_NAME_MAX__0(__attribute__((unused)) void *data) {
    return 63;
}

const test_define_t __test__test_superblocks_stat_tweaked__defines[][TEST_IMPLICIT_DEFINE_COUNT+9] = {
    {
        [TWEAKED_ATTR_MAX_i      ] = {__test__test_superblocks_stat_tweaked__TWEAKED_ATTR_MAX__0, NULL},
        [TWEAKED_FILE_MAX_i      ] = {__test__test_superblocks_stat_tweaked__TWEAKED_FILE_MAX__0, NULL},
        [TWEAKED_NAME_MAX_i      ] = {__test__test_superblocks_stat_tweaked__TWEAKED_NAME_MAX__0, NULL},
    },
};

bool __test__test_superblocks_stat_tweaked__filter(void) {
    return (DISK_VERSION == 0);
}

void __test__test_superblocks_stat_tweaked__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_stat_tweaked
    #line 78 "tests/test_superblocks.toml"
    // create filesystem with tweaked params
    struct lfs_config tweaked_cfg = *cfg;
    tweaked_cfg.name_max = TWEAKED_NAME_MAX;
    tweaked_cfg.file_max = TWEAKED_FILE_MAX;
    tweaked_cfg.attr_max = TWEAKED_ATTR_MAX;

    lfs_t lfs;
    lfs_format(&lfs, &tweaked_cfg) => 0;

    // test we can mount and read these params with the original config
    lfs_mount(&lfs, cfg) => 0;

    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.disk_version == LFS_DISK_VERSION);
    assert(fsinfo.name_max == TWEAKED_NAME_MAX);
    assert(fsinfo.file_max == TWEAKED_FILE_MAX);
    assert(fsinfo.attr_max == TWEAKED_ATTR_MAX);

    lfs_unmount(&lfs) => 0;
    #line 171 "tests/test_superblocks.t.a.c"
}

intmax_t __test__test_superblocks_expand__BLOCK_CYCLES__0(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_superblocks_expand__N__0(__attribute__((unused)) void *data) {
    return 10;
}

intmax_t __test__test_superblocks_expand__N__1(__attribute__((unused)) void *data) {
    return 100;
}

intmax_t __test__test_superblocks_expand__N__2(__attribute__((unused)) void *data) {
    return 1000;
}

intmax_t __test__test_superblocks_expand__BLOCK_CYCLES__3(__attribute__((unused)) void *data) {
    return 33;
}

intmax_t __test__test_superblocks_expand__BLOCK_CYCLES__6(__attribute__((unused)) void *data) {
    return 1;
}

const test_define_t __test__test_superblocks_expand__defines[][TEST_IMPLICIT_DEFINE_COUNT+9] = {
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand__BLOCK_CYCLES__0, NULL},
        [N_i                     ] = {__test__test_superblocks_expand__N__0, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand__BLOCK_CYCLES__0, NULL},
        [N_i                     ] = {__test__test_superblocks_expand__N__1, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand__BLOCK_CYCLES__0, NULL},
        [N_i                     ] = {__test__test_superblocks_expand__N__2, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand__BLOCK_CYCLES__3, NULL},
        [N_i                     ] = {__test__test_superblocks_expand__N__0, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand__BLOCK_CYCLES__3, NULL},
        [N_i                     ] = {__test__test_superblocks_expand__N__1, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand__BLOCK_CYCLES__3, NULL},
        [N_i                     ] = {__test__test_superblocks_expand__N__2, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand__BLOCK_CYCLES__6, NULL},
        [N_i                     ] = {__test__test_superblocks_expand__N__0, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand__BLOCK_CYCLES__6, NULL},
        [N_i                     ] = {__test__test_superblocks_expand__N__1, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand__BLOCK_CYCLES__6, NULL},
        [N_i                     ] = {__test__test_superblocks_expand__N__2, NULL},
    },
};

void __test__test_superblocks_expand__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_expand
    #line 105 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;
    lfs_mount(&lfs, cfg) => 0;
    for (int i = 0; i < N; i++) {
        lfs_file_t file;
        lfs_file_open(&lfs, &file, "dummy",
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        lfs_file_close(&lfs, &file) => 0;
        struct lfs_info info;
        lfs_stat(&lfs, "dummy", &info) => 0;
        assert(strcmp(info.name, "dummy") == 0);
        assert(info.type == LFS_TYPE_REG);
        lfs_remove(&lfs, "dummy") => 0;
    }
    lfs_unmount(&lfs) => 0;

    // one last check after power-cycle
    lfs_mount(&lfs, cfg) => 0;
    lfs_file_t file;
    lfs_file_open(&lfs, &file, "dummy",
            LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
    lfs_file_close(&lfs, &file) => 0;
    struct lfs_info info;
    lfs_stat(&lfs, "dummy", &info) => 0;
    assert(strcmp(info.name, "dummy") == 0);
    assert(info.type == LFS_TYPE_REG);
    lfs_unmount(&lfs) => 0;
    #line 267 "tests/test_superblocks.t.a.c"
}

intmax_t __test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__0(__attribute__((unused)) void *data) {
    return 32;
}

intmax_t __test__test_superblocks_expand_power_cycle__N__0(__attribute__((unused)) void *data) {
    return 10;
}

intmax_t __test__test_superblocks_expand_power_cycle__N__1(__attribute__((unused)) void *data) {
    return 100;
}

intmax_t __test__test_superblocks_expand_power_cycle__N__2(__attribute__((unused)) void *data) {
    return 1000;
}

intmax_t __test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__3(__attribute__((unused)) void *data) {
    return 33;
}

intmax_t __test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__6(__attribute__((unused)) void *data) {
    return 1;
}

const test_define_t __test__test_superblocks_expand_power_cycle__defines[][TEST_IMPLICIT_DEFINE_COUNT+9] = {
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__0, NULL},
        [N_i                     ] = {__test__test_superblocks_expand_power_cycle__N__0, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__0, NULL},
        [N_i                     ] = {__test__test_superblocks_expand_power_cycle__N__1, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__0, NULL},
        [N_i                     ] = {__test__test_superblocks_expand_power_cycle__N__2, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__3, NULL},
        [N_i                     ] = {__test__test_superblocks_expand_power_cycle__N__0, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__3, NULL},
        [N_i                     ] = {__test__test_superblocks_expand_power_cycle__N__1, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__3, NULL},
        [N_i                     ] = {__test__test_superblocks_expand_power_cycle__N__2, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__6, NULL},
        [N_i                     ] = {__test__test_superblocks_expand_power_cycle__N__0, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__6, NULL},
        [N_i                     ] = {__test__test_superblocks_expand_power_cycle__N__1, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_expand_power_cycle__BLOCK_CYCLES__6, NULL},
        [N_i                     ] = {__test__test_superblocks_expand_power_cycle__N__2, NULL},
    },
};

void __test__test_superblocks_expand_power_cycle__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_expand_power_cycle
    #line 139 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;
    for (int i = 0; i < N; i++) {
        lfs_mount(&lfs, cfg) => 0;
        // remove lingering dummy?
        struct lfs_info info;
        int err = lfs_stat(&lfs, "dummy", &info);
        assert(err == 0 || (err == LFS_ERR_NOENT && i == 0));
        if (!err) {
            assert(strcmp(info.name, "dummy") == 0);
            assert(info.type == LFS_TYPE_REG);
            lfs_remove(&lfs, "dummy") => 0;
        }

        lfs_file_t file;
        lfs_file_open(&lfs, &file, "dummy",
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        lfs_file_close(&lfs, &file) => 0;
        lfs_stat(&lfs, "dummy", &info) => 0;
        assert(strcmp(info.name, "dummy") == 0);
        assert(info.type == LFS_TYPE_REG);
        lfs_unmount(&lfs) => 0;
    }

    // one last check after power-cycle
    lfs_mount(&lfs, cfg) => 0;
    struct lfs_info info;
    lfs_stat(&lfs, "dummy", &info) => 0;
    assert(strcmp(info.name, "dummy") == 0);
    assert(info.type == LFS_TYPE_REG);
    lfs_unmount(&lfs) => 0;
    #line 367 "tests/test_superblocks.t.a.c"
}

intmax_t __test__test_superblocks_reentrant_expand__BLOCK_CYCLES__0(__attribute__((unused)) void *data) {
    return 2;
}

intmax_t __test__test_superblocks_reentrant_expand__N__0(__attribute__((unused)) void *data) {
    return 24;
}

intmax_t __test__test_superblocks_reentrant_expand__BLOCK_CYCLES__1(__attribute__((unused)) void *data) {
    return 1;
}

const test_define_t __test__test_superblocks_reentrant_expand__defines[][TEST_IMPLICIT_DEFINE_COUNT+9] = {
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_reentrant_expand__BLOCK_CYCLES__0, NULL},
        [N_i                     ] = {__test__test_superblocks_reentrant_expand__N__0, NULL},
    },
    {
        [BLOCK_CYCLES_i          ] = {__test__test_superblocks_reentrant_expand__BLOCK_CYCLES__1, NULL},
        [N_i                     ] = {__test__test_superblocks_reentrant_expand__N__0, NULL},
    },
};

void __test__test_superblocks_reentrant_expand__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_reentrant_expand
    #line 178 "tests/test_superblocks.toml"
    lfs_t lfs;
    int err = lfs_mount(&lfs, cfg);
    if (err) {
        lfs_format(&lfs, cfg) => 0;
        lfs_mount(&lfs, cfg) => 0;
    }

    for (int i = 0; i < N; i++) {
        // remove lingering dummy?
        struct lfs_info info;
        err = lfs_stat(&lfs, "dummy", &info);
        assert(err == 0 || (err == LFS_ERR_NOENT && i == 0));
        if (!err) {
            assert(strcmp(info.name, "dummy") == 0);
            assert(info.type == LFS_TYPE_REG);
            lfs_remove(&lfs, "dummy") => 0;
        }

        lfs_file_t file;
        lfs_file_open(&lfs, &file, "dummy",
                LFS_O_WRONLY | LFS_O_CREAT | LFS_O_EXCL) => 0;
        lfs_file_close(&lfs, &file) => 0;
        lfs_stat(&lfs, "dummy", &info) => 0;
        assert(strcmp(info.name, "dummy") == 0);
        assert(info.type == LFS_TYPE_REG);
    }

    lfs_unmount(&lfs) => 0;

    // one last check after power-cycle
    lfs_mount(&lfs, cfg) => 0;
    struct lfs_info info;
    lfs_stat(&lfs, "dummy", &info) => 0;
    assert(strcmp(info.name, "dummy") == 0);
    assert(info.type == LFS_TYPE_REG);
    lfs_unmount(&lfs) => 0;
    #line 432 "tests/test_superblocks.t.a.c"
}

void __test__test_superblocks_unknown_blocks__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_unknown_blocks
    #line 219 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // known block_size/block_count
    cfg->block_size = BLOCK_SIZE;
    cfg->block_count = BLOCK_COUNT;
    lfs_mount(&lfs, cfg) => 0;
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_unmount(&lfs) => 0;

    // unknown block_count
    cfg->block_size = BLOCK_SIZE;
    cfg->block_count = 0;
    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_unmount(&lfs) => 0;

    // do some work
    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_file_t file;
    lfs_file_open(&lfs, &file, "test",
            LFS_O_CREAT | LFS_O_EXCL | LFS_O_WRONLY) => 0;
    lfs_file_write(&lfs, &file, "hello!", 6) => 6;
    lfs_file_close(&lfs, &file) => 0;
    lfs_unmount(&lfs) => 0;

    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_file_open(&lfs, &file, "test", LFS_O_RDONLY) => 0;
    uint8_t buffer[256];
    lfs_file_read(&lfs, &file, buffer, sizeof(buffer)) => 6;
    lfs_file_close(&lfs, &file) => 0;
    assert(memcmp(buffer, "hello!", 6) == 0);
    lfs_unmount(&lfs) => 0;
    #line 482 "tests/test_superblocks.t.a.c"
}

intmax_t __test__test_superblocks_fewer_blocks__BLOCK_COUNT__0(__attribute__((unused)) void *data) {
    return ERASE_COUNT/2;
}

intmax_t __test__test_superblocks_fewer_blocks__BLOCK_COUNT__1(__attribute__((unused)) void *data) {
    return ERASE_COUNT/4;
}

intmax_t __test__test_superblocks_fewer_blocks__BLOCK_COUNT__2(__attribute__((unused)) void *data) {
    return 2;
}

const test_define_t __test__test_superblocks_fewer_blocks__defines[][TEST_IMPLICIT_DEFINE_COUNT+9] = {
    {
        [BLOCK_COUNT_i           ] = {__test__test_superblocks_fewer_blocks__BLOCK_COUNT__0, NULL},
    },
    {
        [BLOCK_COUNT_i           ] = {__test__test_superblocks_fewer_blocks__BLOCK_COUNT__1, NULL},
    },
    {
        [BLOCK_COUNT_i           ] = {__test__test_superblocks_fewer_blocks__BLOCK_COUNT__2, NULL},
    },
};

void __test__test_superblocks_fewer_blocks__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_fewer_blocks
    #line 269 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    // known block_size/block_count
    cfg->block_size = BLOCK_SIZE;
    cfg->block_count = BLOCK_COUNT;
    lfs_mount(&lfs, cfg) => 0;
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_unmount(&lfs) => 0;

    // incorrect block_count
    cfg->block_size = BLOCK_SIZE;
    cfg->block_count = ERASE_COUNT;
    lfs_mount(&lfs, cfg) => LFS_ERR_INVAL;

    // unknown block_count
    cfg->block_size = BLOCK_SIZE;
    cfg->block_count = 0;
    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_unmount(&lfs) => 0;

    // do some work
    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_file_t file;
    lfs_file_open(&lfs, &file, "test",
            LFS_O_CREAT | LFS_O_EXCL | LFS_O_WRONLY) => 0;
    lfs_file_write(&lfs, &file, "hello!", 6) => 6;
    lfs_file_close(&lfs, &file) => 0;
    lfs_unmount(&lfs) => 0;

    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_file_open(&lfs, &file, "test", LFS_O_RDONLY) => 0;
    uint8_t buffer[256];
    lfs_file_read(&lfs, &file, buffer, sizeof(buffer)) => 6;
    lfs_file_close(&lfs, &file) => 0;
    assert(memcmp(buffer, "hello!", 6) == 0);
    lfs_unmount(&lfs) => 0;
    #line 561 "tests/test_superblocks.t.a.c"
}

extern const test_define_t __test__test_superblocks_more_blocks__defines[][TEST_IMPLICIT_DEFINE_COUNT+9];
extern void __test__test_superblocks_more_blocks__run(struct lfs_config *cfg);

intmax_t __test__test_superblocks_grow__BLOCK_COUNT__0(__attribute__((unused)) void *data) {
    return ERASE_COUNT/2;
}

intmax_t __test__test_superblocks_grow__BLOCK_COUNT_2__0(__attribute__((unused)) void *data) {
    return ERASE_COUNT;
}

intmax_t __test__test_superblocks_grow__KNOWN_BLOCK_COUNT__0(__attribute__((unused)) void *data) {
    return true;
}

intmax_t __test__test_superblocks_grow__KNOWN_BLOCK_COUNT__1(__attribute__((unused)) void *data) {
    return false;
}

intmax_t __test__test_superblocks_grow__BLOCK_COUNT__2(__attribute__((unused)) void *data) {
    return ERASE_COUNT/4;
}

intmax_t __test__test_superblocks_grow__BLOCK_COUNT__4(__attribute__((unused)) void *data) {
    return 2;
}

const test_define_t __test__test_superblocks_grow__defines[][TEST_IMPLICIT_DEFINE_COUNT+9] = {
    {
        [BLOCK_COUNT_i           ] = {__test__test_superblocks_grow__BLOCK_COUNT__0, NULL},
        [BLOCK_COUNT_2_i         ] = {__test__test_superblocks_grow__BLOCK_COUNT_2__0, NULL},
        [KNOWN_BLOCK_COUNT_i     ] = {__test__test_superblocks_grow__KNOWN_BLOCK_COUNT__0, NULL},
    },
    {
        [BLOCK_COUNT_i           ] = {__test__test_superblocks_grow__BLOCK_COUNT__0, NULL},
        [BLOCK_COUNT_2_i         ] = {__test__test_superblocks_grow__BLOCK_COUNT_2__0, NULL},
        [KNOWN_BLOCK_COUNT_i     ] = {__test__test_superblocks_grow__KNOWN_BLOCK_COUNT__1, NULL},
    },
    {
        [BLOCK_COUNT_i           ] = {__test__test_superblocks_grow__BLOCK_COUNT__2, NULL},
        [BLOCK_COUNT_2_i         ] = {__test__test_superblocks_grow__BLOCK_COUNT_2__0, NULL},
        [KNOWN_BLOCK_COUNT_i     ] = {__test__test_superblocks_grow__KNOWN_BLOCK_COUNT__0, NULL},
    },
    {
        [BLOCK_COUNT_i           ] = {__test__test_superblocks_grow__BLOCK_COUNT__2, NULL},
        [BLOCK_COUNT_2_i         ] = {__test__test_superblocks_grow__BLOCK_COUNT_2__0, NULL},
        [KNOWN_BLOCK_COUNT_i     ] = {__test__test_superblocks_grow__KNOWN_BLOCK_COUNT__1, NULL},
    },
    {
        [BLOCK_COUNT_i           ] = {__test__test_superblocks_grow__BLOCK_COUNT__4, NULL},
        [BLOCK_COUNT_2_i         ] = {__test__test_superblocks_grow__BLOCK_COUNT_2__0, NULL},
        [KNOWN_BLOCK_COUNT_i     ] = {__test__test_superblocks_grow__KNOWN_BLOCK_COUNT__0, NULL},
    },
    {
        [BLOCK_COUNT_i           ] = {__test__test_superblocks_grow__BLOCK_COUNT__4, NULL},
        [BLOCK_COUNT_2_i         ] = {__test__test_superblocks_grow__BLOCK_COUNT_2__0, NULL},
        [KNOWN_BLOCK_COUNT_i     ] = {__test__test_superblocks_grow__KNOWN_BLOCK_COUNT__1, NULL},
    },
};

void __test__test_superblocks_grow__run(__attribute__((unused)) struct lfs_config *cfg) {
    // test case test_superblocks_grow
    #line 369 "tests/test_superblocks.toml"
    lfs_t lfs;
    lfs_format(&lfs, cfg) => 0;

    if (KNOWN_BLOCK_COUNT) {
        cfg->block_count = BLOCK_COUNT;
    } else {
        cfg->block_count = 0;
    }

    // mount with block_size < erase_size
    lfs_mount(&lfs, cfg) => 0;
    struct lfs_fsinfo fsinfo;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_unmount(&lfs) => 0;

    // same size is a noop
    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_grow(&lfs, BLOCK_COUNT) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_unmount(&lfs) => 0;

    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT);
    lfs_unmount(&lfs) => 0;

    // grow to new size
    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_grow(&lfs, BLOCK_COUNT_2) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT_2);
    lfs_unmount(&lfs) => 0;

    if (KNOWN_BLOCK_COUNT) {
        cfg->block_count = BLOCK_COUNT_2;
    } else {
        cfg->block_count = 0;
    }

    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT_2);
    lfs_unmount(&lfs) => 0;

    // mounting with the previous size should fail
    cfg->block_count = BLOCK_COUNT;
    lfs_mount(&lfs, cfg) => LFS_ERR_INVAL;

    if (KNOWN_BLOCK_COUNT) {
        cfg->block_count = BLOCK_COUNT_2;
    } else {
        cfg->block_count = 0;
    }

    // same size is a noop
    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_grow(&lfs, BLOCK_COUNT_2) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT_2);
    lfs_unmount(&lfs) => 0;

    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT_2);
    lfs_unmount(&lfs) => 0;

    // do some work
    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT_2);
    lfs_file_t file;
    lfs_file_open(&lfs, &file, "test",
            LFS_O_CREAT | LFS_O_EXCL | LFS_O_WRONLY) => 0;
    lfs_file_write(&lfs, &file, "hello!", 6) => 6;
    lfs_file_close(&lfs, &file) => 0;
    lfs_unmount(&lfs) => 0;

    lfs_mount(&lfs, cfg) => 0;
    lfs_fs_stat(&lfs, &fsinfo) => 0;
    assert(fsinfo.block_size == BLOCK_SIZE);
    assert(fsinfo.block_count == BLOCK_COUNT_2);
    lfs_file_open(&lfs, &file, "test", LFS_O_RDONLY) => 0;
    uint8_t buffer[256];
    lfs_file_read(&lfs, &file, buffer, sizeof(buffer)) => 6;
    lfs_file_close(&lfs, &file) => 0;
    assert(memcmp(buffer, "hello!", 6) == 0);
    lfs_unmount(&lfs) => 0;
    #line 724 "tests/test_superblocks.t.a.c"
}

__attribute__((section("_test_suites"), aligned(1)))
const struct test_suite __test__test_superblocks__suite = {
    .name = "test_superblocks",
    .path = "tests/test_superblocks.toml",
    .flags = TEST_REENTRANT,
    .define_names = (const char *const[TEST_IMPLICIT_DEFINE_COUNT+9]){
        [BLOCK_COUNT_i           ] = "BLOCK_COUNT",
        [BLOCK_COUNT_2_i         ] = "BLOCK_COUNT_2",
        [BLOCK_CYCLES_i          ] = "BLOCK_CYCLES",
        [FORMAT_BLOCK_COUNT_i    ] = "FORMAT_BLOCK_COUNT",
        [KNOWN_BLOCK_COUNT_i     ] = "KNOWN_BLOCK_COUNT",
        [N_i                     ] = "N",
        [TWEAKED_ATTR_MAX_i      ] = "TWEAKED_ATTR_MAX",
        [TWEAKED_FILE_MAX_i      ] = "TWEAKED_FILE_MAX",
        [TWEAKED_NAME_MAX_i      ] = "TWEAKED_NAME_MAX",
    },
    .define_count = TEST_IMPLICIT_DEFINE_COUNT+9,
    .cases = (const struct test_case[]){
        {
            .name = "test_superblocks_format",
            .path = "tests/test_superblocks.toml:2",
            .flags = 0,
            .permutations = 1,
            .run = __test__test_superblocks_format__run,
        },
        {
            .name = "test_superblocks_mount",
            .path = "tests/test_superblocks.toml:9",
            .flags = 0,
            .permutations = 1,
            .run = __test__test_superblocks_mount__run,
        },
        {
            .name = "test_superblocks_mount_unknown_block_count",
            .path = "tests/test_superblocks.toml:18",
            .flags = 0,
            .permutations = 1,
            .run = __test__test_superblocks_mount_unknown_block_count__run,
        },
        {
            .name = "test_superblocks_reentrant_format",
            .path = "tests/test_superblocks.toml:33",
            .flags = TEST_REENTRANT,
            .permutations = 1,
            .run = __test__test_superblocks_reentrant_format__run,
        },
        {
            .name = "test_superblocks_invalid_mount",
            .path = "tests/test_superblocks.toml:46",
            .flags = 0,
            .permutations = 1,
            .run = __test__test_superblocks_invalid_mount__run,
        },
        {
            .name = "test_superblocks_stat",
            .path = "tests/test_superblocks.toml:53",
            .flags = 0,
            .permutations = 1,
            .filter = __test__test_superblocks_stat__filter,
            .run = __test__test_superblocks_stat__run,
        },
        {
            .name = "test_superblocks_stat_tweaked",
            .path = "tests/test_superblocks.toml:72",
            .flags = 0,
            .permutations = 1,
            .defines = (const test_define_t*)__test__test_superblocks_stat_tweaked__defines,
            .filter = __test__test_superblocks_stat_tweaked__filter,
            .run = __test__test_superblocks_stat_tweaked__run,
        },
        {
            .name = "test_superblocks_expand",
            .path = "tests/test_superblocks.toml:101",
            .flags = 0,
            .permutations = 9,
            .defines = (const test_define_t*)__test__test_superblocks_expand__defines,
            .run = __test__test_superblocks_expand__run,
        },
        {
            .name = "test_superblocks_expand_power_cycle",
            .path = "tests/test_superblocks.toml:135",
            .flags = 0,
            .permutations = 9,
            .defines = (const test_define_t*)__test__test_superblocks_expand_power_cycle__defines,
            .run = __test__test_superblocks_expand_power_cycle__run,
        },
        {
            .name = "test_superblocks_reentrant_expand",
            .path = "tests/test_superblocks.toml:173",
            .flags = TEST_REENTRANT,
            .permutations = 2,
            .defines = (const test_define_t*)__test__test_superblocks_reentrant_expand__defines,
            .run = __test__test_superblocks_reentrant_expand__run,
        },
        {
            .name = "test_superblocks_unknown_blocks",
            .path = "tests/test_superblocks.toml:217",
            .flags = 0,
            .permutations = 1,
            .run = __test__test_superblocks_unknown_blocks__run,
        },
        {
            .name = "test_superblocks_fewer_blocks",
            .path = "tests/test_superblocks.toml:266",
            .flags = 0,
            .permutations = 3,
            .defines = (const test_define_t*)__test__test_superblocks_fewer_blocks__defines,
            .run = __test__test_superblocks_fewer_blocks__run,
        },
        {
            .name = "test_superblocks_more_blocks",
            .path = "tests/test_superblocks.toml:321",
            .flags = 0,
            .permutations = 1,
            .defines = (const test_define_t*)__test__test_superblocks_more_blocks__defines,
            .run = __test__test_superblocks_more_blocks__run,
        },
        {
            .name = "test_superblocks_grow",
            .path = "tests/test_superblocks.toml:364",
            .flags = 0,
            .permutations = 6,
            .defines = (const test_define_t*)__test__test_superblocks_grow__defines,
            .run = __test__test_superblocks_grow__run,
        },
    },
    .case_count = 14,
};

